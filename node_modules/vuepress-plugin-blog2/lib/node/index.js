"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("@vuepress/core");const t=new(require("@mr-hope/vuepress-shared").Logger)("vuepress-plugin-blog2"),a=(e,t)=>{const{filter:a=(e=>Boolean(e.filePathRelative)&&!e.frontmatter.home)}=e,o={};return t.pages.filter(a).forEach((e=>{o[e.pathLocale]||(o[e.pathLocale]=[]),o[e.pathLocale].push(e)})),o},o=e=>e.replace(/^\//,""),n=(a,n,r)=>{const{category:p=[],slugify:s=(e=>e.replace(/[ _]/g,"-").toLowerCase())}=n;return Promise.all(p.map((async({key:n,getter:p,sorter:i=(()=>-1),path:g="",layout:l="Layout",itemPath:u="",itemLayout:c="Layout"},y)=>{if("string"!=typeof n||!n)return t.error(`Invalid 'key' option ${n} in 'category[${y}]'`),null;if("function"!=typeof p)return t.error(`Invalid 'getter' option in 'category[${y}]', it should be a function!`),null;a.env.isDebug&&t.info(`Generating ${n} category.\n`);const h={},f=[],m="function"==typeof u?u:e=>u.replace(/:key/g,s(n)).replace(/:name/g,s(e));for(const u in r){if(g){const t=await e.createPage(a,{path:`${u}${o(g.replace(/:key/g,s(n)))}`,frontmatter:{blog:{type:"category",key:n},layout:l}});a.pages.push(t),f.push(t.path),h[u]={path:t.path,map:{}}}else h[u]={path:"",map:{}};const{map:y}=h[u],_={};for(const t of r[u]){const r=p(t);for(const p of r){if(!y[p]){const t=m(p);if(t){const r=await e.createPage(a,{path:`${u}${o(t)}`,frontmatter:{blog:{type:"category",name:p,key:n},layout:c}});a.pages.push(r),f.push(r.path),y[p]={path:r.path,keys:[]}}else y[p]={path:"",keys:[]};_[p]=[]}_[p].push(t)}}for(const e in _)y[e].keys=_[e].sort(i).map((({key:e})=>e));if(a.env.isDebug){let e=`Route ${u} in ${n} cateogry:\n`;for(const t in y){const{path:a,keys:o}=y[t];e+=`name: ${t}; ${a?`path: ${a}; `:""}items: ${o.length}`}t.info(e)}}return{key:n,map:h,pagePaths:f}}))).then((async e=>{const o={},n=[];return e.filter((e=>null!==e)).forEach((({key:e,map:t,pagePaths:a})=>{o[e]=t,n.push(...a)})),await a.writeTemp("blog/category.js",`export const categoryMap = ${JSON.stringify(o)}\n\nif (import.meta.webpackHot) {\n  import.meta.webpackHot.accept()\n  if (__VUE_HMR_RUNTIME__.updateBlogCategory) {\n    __VUE_HMR_RUNTIME__.updateBlogCategory(categoryMap)\n  }\n}\n\nif (import.meta.hot) {\n  import.meta.hot.accept(({ categoryMap }) => {\n    __VUE_HMR_RUNTIME__.updateBlogCategory(categoryMap)\n  })\n}\n`),a.env.isDebug&&t.info("All types generated."),n}))},r=(a,n,r)=>{const{type:p=[],slugify:s=(e=>e.replace(/[ _]/g,"-").toLowerCase())}=n;return Promise.all(p.map((async({key:n,sorter:p=(()=>-1),filter:i=(()=>!0),path:g="",layout:l="Layout"},u)=>{if("string"!=typeof n||!n)return t.error(`Invalid 'key' option ${n} in 'category[${u}]'`),null;const c={},y=[];a.env.isDebug&&t.info(`Generating ${n} type.\n`);for(const u in r){const h=r[u].filter(i).sort(p).map((({key:e})=>e));if(g){const r=await e.createPage(a,{path:`${u}${o(s(g.replace(/:key/g,n)))}`,frontmatter:{blog:{type:"type",key:n},layout:l}});a.pages.push(r),y.push(r.path),c[u]={path:r.path,keys:h},a.env.isDebug&&t.info(`Route ${u} in ${n} type: path: ${r.path}; items: ${h.length}`)}else c[u]={path:"",keys:h},a.env.isDebug&&t.info(`Route ${u} in ${n} type: items: ${h.length}`)}return{key:n,map:c,pagePaths:y}}))).then((async e=>{const o={},n=[];return e.filter((e=>null!==e)).forEach((({key:e,map:t,pagePaths:a})=>{o[e]=t,n.push(...a)})),await a.writeTemp("blog/type.js",`export const typeMap = ${JSON.stringify(o)}\n\nif (import.meta.webpackHot) {\n  import.meta.webpackHot.accept()\n  if (__VUE_HMR_RUNTIME__.updateBlogType) {\n    __VUE_HMR_RUNTIME__.updateBlogType(typeMap)\n  }\n}\n\nif (import.meta.hot) {\n  import.meta.hot.accept(({ typeMap }) => {\n    __VUE_HMR_RUNTIME__.updateBlogType(typeMap)\n  })\n}\n`),a.env.isDebug&&t.info("All types generated."),n}))},p=o=>{const{getInfo:p=(()=>({})),metaScope:s="_blog"}=o;let i=[];return{name:"vuepress-plugin-blog2",define:()=>({BLOG_META_SCOPE:s}),extendsPage(e){e.routeMeta={...""===s?p(e):{[s]:p(e)},...e.routeMeta}},onInitialized(e){const p=a(o,e);return Promise.all([n(e,o,p).then((e=>{i.push(...e)})),r(e,o,p).then((e=>{i.push(...e)}))]).then((()=>{e.env.isDebug&&t.info("temp file generated")}))},onWatched(p){const s=[],g=a(o,p);return Promise.all([n(p,o,g).then((e=>{s.push(...e)})),r(p,o,g).then((e=>{s.push(...e)}))]).then((async()=>{if(s.length!==i.length)await e.preparePagesComponents(p),await e.preparePagesData(p),await e.preparePagesRoutes(p);else for(const t of s)i.includes(t)||(await e.preparePagesComponents(p),await e.preparePagesData(p),await e.preparePagesRoutes(p));i=s,p.env.isDebug&&t.info("temp file updated")}))}}};exports.blog=e=>["blog2",e],exports.blogPlugin=p,exports.default=p;
//# sourceMappingURL=index.js.map
